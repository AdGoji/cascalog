<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>cascalog.ops documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Cascalog-core 1.10.1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="cascalog.api.html"><span>cascalog.api</span></a></li><li><a href="cascalog.conf.html"><span>cascalog.conf</span></a></li><li><a href="cascalog.debug.html"><span>cascalog.debug</span></a></li><li><a href="cascalog.graph.html"><span>cascalog.graph</span></a></li><li><a href="cascalog.io.html"><span>cascalog.io</span></a></li><li class="current"><a href="cascalog.ops.html"><span>cascalog.ops</span></a></li><li><a href="cascalog.ops-impl.html"><span>cascalog.ops-impl</span></a></li><li><a href="cascalog.playground.html"><span>cascalog.playground</span></a></li><li><a href="cascalog.predicate.html"><span>cascalog.predicate</span></a></li><li><a href="cascalog.rules.html"><span>cascalog.rules</span></a></li><li><a href="cascalog.tap.html"><span>cascalog.tap</span></a></li><li><a href="cascalog.testing.html"><span>cascalog.testing</span></a></li><li><a href="cascalog.util.html"><span>cascalog.util</span></a></li><li><a href="cascalog.vars.html"><span>cascalog.vars</span></a></li><li><a href="cascalog.workflow.html"><span>cascalog.workflow</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="cascalog.ops.html#var-all"><span>all</span></a></li><li><a href="cascalog.ops.html#var-any"><span>any</span></a></li><li><a href="cascalog.ops.html#var-avg"><span>avg</span></a></li><li><a href="cascalog.ops.html#var-comp"><span>comp</span></a></li><li><a href="cascalog.ops.html#var-distinct-count"><span>distinct-count</span></a></li><li><a href="cascalog.ops.html#var-each"><span>each</span></a></li><li><a href="cascalog.ops.html#var-first-n"><span>first-n</span></a></li><li><a href="cascalog.ops.html#var-fixed-sample"><span>fixed-sample</span></a></li><li><a href="cascalog.ops.html#var-juxt"><span>juxt</span></a></li><li><a href="cascalog.ops.html#var-lazy-generator"><span>lazy-generator</span></a></li><li><a href="cascalog.ops.html#var-negate"><span>negate</span></a></li><li><a href="cascalog.ops.html#var-partial"><span>partial</span></a></li><li><a href="cascalog.ops.html#var-re-parse"><span>re-parse</span></a></li><li><a href="cascalog.ops.html#var-with-timeout"><span>with-timeout</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>cascalog.ops documentation</h2><pre class="doc"></pre><div class="public" id="var-all"><h3>all</h3><div class="usage"><code>(all &amp; ops)</code></div><pre class="doc">Accepts any number of filtering ops and returns a new op that
checks that every every one of the original filters passes. For
example:

((all #'even? #'positive? #'small?) ?x) ;; within some query

Is equivalent to:

;; within some query
(even? ?x :&gt; ?temp1)
(positive? ?x :&gt; ?temp2)
(small? ?x) :&gt; ?temp3)
(and ?temp1 ?temp2 ?temp3)</pre></div><div class="public" id="var-any"><h3>any</h3><div class="usage"><code>(any &amp; ops)</code></div><pre class="doc">Accepts any number of filtering ops and returns a new op that
checks that at least one of the original filters passes. For
example:

((any #'even? #'positive? #'small?) ?x) ;; within some query

Is equivalent to:

;; within some query
(even? ?x :&gt; ?temp1)
(positive? ?x :&gt; ?temp2)
(small? ?x :&gt; ?temp3)
(or ?temp1 ?temp2 ?temp3)</pre></div><div class="public" id="var-avg"><h3>avg</h3><div class="usage"></div><pre class="doc">Predicate operation that produces the average value of the
supplied input variable. For example:

(let [src [[1] [2]]]
  (&lt;- [?avg]
      (src ?x)
      (avg ?x :&gt; ?avg)))
;;=&gt; ([1.5])</pre></div><div class="public" id="var-comp"><h3>comp</h3><div class="usage"><code>(comp &amp; ops)</code></div><pre class="doc">Accepts any number of predicate ops and returns an op that is the
composition of those ops.

(require '[cascalog.ops :as c])
((c/comp #'str #'+) ?x ?y :&gt; ?sum-string) ;; within some query

Is equivalent to:

;; within some query
(+ ?x ?y :&gt; ?intermediate)
(str ?intermediate :&gt; ?sum-string)</pre></div><div class="public" id="var-distinct-count"><h3>distinct-count</h3><div class="usage"></div><pre class="doc">Predicate operation that produces a count of all distinct
values of the supplied input variable. For example:

(let [src [[1] [2] [2]]]
(&lt;- [?count]
    (src ?x)
    (distinct-count ?x :&gt; ?count)))
;;=&gt; ([2])</pre></div><div class="public" id="var-each"><h3>each</h3><div class="usage"><code>(each op)</code></div><pre class="doc">Accepts an operation and returns a predicate macro that maps `op`
across any number of input variables. For example:

((each #'str) ?x ?y ?z :&gt; ?x-str ?y-str ?z-str) ;; within some query

Is equivalent to

;; within some query
(str ?x :&gt; ?x-str)
(str ?y :&gt; ?y-str)
(str ?z :&gt; ?z-str)</pre></div><div class="public" id="var-first-n"><h3>first-n</h3><div class="usage"><code>(first-n gen n &amp; options__438__auto__)</code></div><pre class="doc">Accepts a generator and a number `n` and returns a subquery that
 produces the first n elements from the supplied generator. Two
 boolean keyword arguments are supported:

:sort -- accepts a vector of variables on which to sort. Defaults to
         nil (unsorted).
:reverse -- If true, sorts items in reverse order. (false by default).

For example:

(def src [[1] [3] [2]]) ;; produces 3 tuples

;; produces ([1 2] [3 4] [2 3]) when executed
(def query (&lt;- [?x ?y] (src ?x) (inc ?x :&gt; ?y)))

;; produces ([3 4]) when executed
(first-n query 1 :sort [&quot;?x&quot;] :reverse true)</pre></div><div class="public" id="var-fixed-sample"><h3>fixed-sample</h3><div class="usage"><code>(fixed-sample gen n)</code></div><pre class="doc">Returns a subquery getting a random sample of n elements from the generator
</pre></div><div class="public" id="var-juxt"><h3>juxt</h3><div class="usage"><code>(juxt &amp; ops)</code></div><pre class="doc">Accepts any number of predicate ops and returns an op that is the
juxtaposition of those ops.

(require '[cascalog.ops :as c])
((c/juxt #'+ #'- #'&lt;) !x !y :&gt; !sum !diff !mult) ;; within some query

Is equivalent to:

;; within some query
(+ !x !y :&gt; !sum)
(- !x !y :&gt; !diff)
(* !x !y :&gt; !mult)</pre></div><div class="public" id="var-lazy-generator"><h3>lazy-generator</h3><div class="usage"><code>(lazy-generator tmp-path [tuple :as l-seq])</code></div><pre class="doc">Returns a cascalog generator on the supplied sequence of
tuples. `lazy-generator` serializes each item in the lazy sequence
into a sequencefile located at the supplied temporary directory and returns
a tap for the data in that directory.

It's recommended to wrap queries that use this tap with
`cascalog.io/with-fs-tmp`; for example,

  (with-fs-tmp [_ tmp-dir]
    (let [lazy-tap (lazy-generator tmp-dir lazy-seq)]
      (?&lt;- (stdout)
           [?field1 ?field2 ... etc]
           (lazy-tap ?field1 ?field2)
           ...)))</pre></div><div class="public" id="var-negate"><h3>negate</h3><div class="usage"><code>(negate op)</code></div><pre class="doc">Accepts a filtering op and returns an new op that acts as the
negation (or complement) of the original. For example:

((negate #'string?) ?string-var) ;; within some query

Is equivalent to

;; within some query
(string? ?string-var :&gt; ?temp-bool)
(not ?temp-bool)</pre></div><div class="public" id="var-partial"><h3>partial</h3><div class="usage"><code>(partial op &amp; args)</code></div><pre class="doc">Accepts an operation and fewer than normal arguments, and returns a
new operation that can be called with the remaining unspecified
args. For example, given this require and defmapop:

(require '[cascalog.ops :as c])
(defmapop plus [x y] (+ x y))

The following two forms are equivalent:

(let [plus-10 (c/partial plus 10)]
   (&lt;- [?y] (src ?x) (plus-10 ?x :&gt; ?y)))

(&lt;- [?y] (src ?x) (plus-10 ?x :&gt; ?y))

With the benefit that `10` doesn't need to be hardcoded into the
first query.</pre></div><div class="public" id="var-re-parse"><h3>re-parse</h3><div class="usage"><code>(re-parse str)</code></div><pre class="doc">Accepts a regex `pattern` and a string argument `str` and returns
the groups within `str` that match the supplied `pattern`.</pre></div><div class="public" id="var-with-timeout"><h3>with-timeout</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-timeout [ms] &amp; body)</code></div><pre class="doc">Accepts a vector with a timeout (in ms) and any number of forms and
executes those forms sequentially. returns the result of the last
form or nil (if the timeout is reached.) For example:

(with-timeout [100]
  (Thread/sleep 50)
  &quot;done!&quot;)
;;=&gt; &quot;done!&quot;

(with-timeout [100]
  (Thread/sleep 200)
  &quot;done!&quot;)
;;=&gt; nil</pre></div></div></body></html>